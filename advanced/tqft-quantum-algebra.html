<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TQFT & Quantum Algebra - Advanced Mathematics | Math.help</title>
    <meta name="description" content="Explore Topological Quantum Field Theory and Quantum Algebra: cobordism hypothesis, quantum groups, knot invariants, and Chern-Simons theory.">
    
    <!-- CSS -->
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../ad-styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    
    <!-- Visualization Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        .cobordism-viz {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            min-height: 500px;
        }
        
        .quantum-group {
            width: 100%;
            height: 400px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .knot-invariant {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .knot-diagram {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .chern-simons {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }
        
        .jones-polynomial {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .modular-tensor {
            width: 100%;
            height: 400px;
            margin: 20px 0;
        }
        
        .fusion-rules {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        
        .atiyah-axioms {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .quantum-dimension {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .braid-group {
            width: 100%;
            height: 300px;
            margin: 20px 0;
        }
        
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .r-matrix {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1 class="site-title">Math.help</h1>
            <p class="tagline">Advanced Mathematics Research</p>
        </div>
    </header>
    
    <nav class="main-nav">
        <div class="container">
            <ul class="nav-list">
                <li><a href="/">Home</a></li>
                <li><a href="/advanced/">Advanced Topics</a></li>
                <li><a href="/advanced/tqft-quantum-algebra.html" class="active">TQFT & Quantum Algebra</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="content-wrapper">
                <div class="main-content">
                    <h1>Topological Quantum Field Theory & Quantum Algebra</h1>
                    
                    <div class="intro-section">
                        <p class="lead">Topological Quantum Field Theory (TQFT) bridges pure mathematics and theoretical physics, providing invariants of manifolds through functorial assignments. Quantum algebras, including quantum groups and their representations, form the algebraic backbone of these theories.</p>
                    </div>
                    
                    <!-- Core Concepts -->
                    <section class="concept-section">
                        <h2>Atiyah's TQFT Axioms</h2>
                        
                        <div class="atiyah-axioms">
                            <h3>TQFT Definition</h3>
                            <p>A TQFT is a functor $Z: \text{Cob}_n \to \text{Vect}_k$ satisfying:</p>
                            <ol>
                                <li><strong>Functoriality:</strong> $Z(M_1 \sqcup M_2) = Z(M_1) \otimes Z(M_2)$</li>
                                <li><strong>Identity:</strong> $Z(\emptyset) = k$</li>
                                <li><strong>Duality:</strong> $Z(\overline{M}) = Z(M)^*$</li>
                                <li><strong>Trace:</strong> $Z(S^1 \times M) = \text{dim}(Z(M))$</li>
                            </ol>
                        </div>
                        
                        <div class="theorem-box">
                            <h3>Cobordism Hypothesis (Baez-Dolan, Lurie)</h3>
                            <p>The n-groupoid of fully dualizable objects in a symmetric monoidal (∞,n)-category classifies framed extended TQFTs.</p>
                        </div>
                    </section>
                    
                    <!-- Cobordism Visualization -->
                    <section class="visualization-section">
                        <h2>Cobordism Categories</h2>
                        <div class="control-panel">
                            <label>Dimension: 
                                <select id="cobordism-dim">
                                    <option value="2">2D TQFT</option>
                                    <option value="3" selected>3D TQFT</option>
                                    <option value="4">4D TQFT</option>
                                </select>
                            </label>
                            <button onclick="animateCobordism()">Animate Cobordism</button>
                        </div>
                        <div class="cobordism-viz">
                            <div id="cobordism-3d"></div>
                        </div>
                    </section>
                    
                    <!-- Quantum Groups -->
                    <section class="quantum-section">
                        <h2>Quantum Groups</h2>
                        
                        <div class="definition">
                            <h3>Quantum SL(2)</h3>
                            <p>The quantum group $U_q(\mathfrak{sl}_2)$ is generated by $E, F, K, K^{-1}$ with relations:</p>
                            <ul>
                                <li>$KK^{-1} = K^{-1}K = 1$</li>
                                <li>$KEK^{-1} = q^2E$, $KFK^{-1} = q^{-2}F$</li>
                                <li>$[E,F] = \frac{K - K^{-1}}{q - q^{-1}}$</li>
                            </ul>
                        </div>
                        
                        <div class="quantum-group" id="quantum-group-viz"></div>
                    </section>
                    
                    <!-- Knot Invariants -->
                    <section class="knot-section">
                        <h2>Quantum Knot Invariants</h2>
                        <div class="knot-invariant">
                            <div class="knot-diagram">
                                <h3>Trefoil Knot</h3>
                                <div id="trefoil-knot"></div>
                                <p>Jones Polynomial: $V(q) = q + q^3 - q^4$</p>
                            </div>
                            <div class="knot-diagram">
                                <h3>Hopf Link</h3>
                                <div id="hopf-link"></div>
                                <p>HOMFLY: $P(a,z) = a^{-1}z^{-1} + a^{-1}z$</p>
                            </div>
                        </div>
                        
                        <div class="jones-polynomial">
                            <h3>Jones Polynomial via R-Matrix</h3>
                            <p>The Jones polynomial arises from the R-matrix of $U_q(\mathfrak{sl}_2)$ at $q = e^{2\pi i/k}$:</p>
                            <div class="r-matrix">
                                $$R = q^{1/2} \begin{pmatrix} 
                                q & 0 & 0 & 0 \\
                                0 & 1 & q-q^{-1} & 0 \\
                                0 & 0 & 1 & 0 \\
                                0 & 0 & 0 & q
                                \end{pmatrix}$$
                            </div>
                        </div>
                    </section>
                    
                    <!-- Chern-Simons Theory -->
                    <section class="chern-simons-section">
                        <div class="chern-simons">
                            <h2>Chern-Simons Theory</h2>
                            <p>The Chern-Simons action for a connection $A$ on a 3-manifold $M$:</p>
                            <h3>$$S_{CS}[A] = \frac{k}{4\pi} \int_M \text{Tr}\left(A \wedge dA + \frac{2}{3} A \wedge A \wedge A\right)$$</h3>
                            <p>Quantization gives knot invariants and 3-manifold invariants!</p>
                        </div>
                    </section>
                    
                    <!-- Braid Group Representations -->
                    <section class="braid-section">
                        <h2>Braid Group Representations</h2>
                        <div class="control-panel">
                            <label>Number of strands: 
                                <input type="range" id="braid-strands" min="2" max="5" value="3">
                                <span id="strand-count">3</span>
                            </label>
                            <button onclick="generateBraid()">Generate Random Braid</button>
                        </div>
                        <div class="braid-group" id="braid-viz"></div>
                    </section>
                    
                    <!-- Modular Tensor Categories -->
                    <section class="modular-section">
                        <h2>Modular Tensor Categories</h2>
                        
                        <div class="fusion-rules">
                            <h3>Fusion Rules for SU(2)_k</h3>
                            <p>For level k, the fusion rules are:</p>
                            <div id="fusion-table"></div>
                        </div>
                        
                        <div class="modular-tensor" id="modular-s-matrix"></div>
                        
                        <div class="quantum-dimension">
                            <div>
                                <h4>Quantum Dimensions</h4>
                                <p>$d_j = \frac{\sin(\frac{(j+1)\pi}{k+2})}{\sin(\frac{\pi}{k+2})}$</p>
                            </div>
                            <div>
                                <h4>Total Dimension</h4>
                                <p>$\mathcal{D} = \sqrt{\sum_j d_j^2}$</p>
                            </div>
                        </div>
                    </section>
                    
                    <!-- Extended TQFT -->
                    <section class="extended-section">
                        <h2>Extended TQFT</h2>
                        <div id="extended-tqft-viz"></div>
                        <p>Extended TQFTs assign:</p>
                        <ul>
                            <li>Points → n-categories</li>
                            <li>1-manifolds → (n-1)-categories</li>
                            <li>... continuing down to n-manifolds → numbers</li>
                        </ul>
                    </section>
                    
                    <!-- Applications -->
                    <section class="applications-section">
                        <h2>Revolutionary Applications</h2>
                        
                        <div class="topic-card">
                            <h3>Quantum Computing</h3>
                            <p>Topological quantum computation uses anyons and braiding for fault-tolerant quantum gates.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>Condensed Matter Physics</h3>
                            <p>Topological phases of matter described by TQFTs, including fractional quantum Hall states.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>Low-dimensional Topology</h3>
                            <p>Invariants of 3 and 4-manifolds via quantum groups and gauge theory.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>String Theory</h3>
                            <p>Topological string theory and topological twisting of supersymmetric theories.</p>
                        </div>
                    </section>
                    
                    <!-- Key Research -->
                    <section class="research-section">
                        <h2>Foundational Papers</h2>
                        
                        <div class="research-paper">
                            <div class="paper-title">Quantum Field Theory and the Jones Polynomial</div>
                            <div class="paper-authors">Edward Witten (1989)</div>
                            <a href="https://projecteuclid.org/euclid.cmp/1104178138" class="paper-link">Comm. Math. Phys.</a>
                            <p>Fields Medal winning work connecting Chern-Simons theory to knot invariants.</p>
                        </div>
                        
                        <div class="research-paper">
                            <div class="paper-title">Topological Quantum Field Theories</div>
                            <div class="paper-authors">Michael Atiyah (1988)</div>
                            <a href="https://www.numdam.org/item/PMIHES_1988__68__175_0/" class="paper-link">Publ. Math. IHÉS</a>
                            <p>The axiomatization of TQFT that started the field.</p>
                        </div>
                        
                        <div class="research-paper">
                            <div class="paper-title">Invariants of 3-manifolds via Link Polynomials</div>
                            <div class="paper-authors">N. Reshetikhin, V. Turaev (1991)</div>
                            <a href="https://doi.org/10.1007/BF01239527" class="paper-link">Invent. Math.</a>
                            <p>Construction of 3-manifold invariants from quantum groups.</p>
                        </div>
                        
                        <div class="research-paper">
                            <div class="paper-title">On the Classification of Topological Field Theories</div>
                            <div class="paper-authors">Jacob Lurie (2009)</div>
                            <a href="https://arxiv.org/abs/0905.0465" class="paper-link">arXiv:0905.0465</a>
                            <p>Proof of the cobordism hypothesis using higher category theory.</p>
                        </div>
                    </section>
                    
                    <!-- Research Centers -->
                    <section class="institutions-section">
                        <h2>Leading Research Centers</h2>
                        <ul class="institution-list">
                            <li><strong>Institute for Advanced Study</strong> - Edward Witten</li>
                            <li><strong>Microsoft Station Q</strong> - Topological quantum computing</li>
                            <li><strong>Oxford</strong> - Atiyah's legacy, quantum topology</li>
                            <li><strong>UC Santa Barbara</strong> - KITP, topological phases</li>
                            <li><strong>Perimeter Institute</strong> - Quantum gravity and TQFT</li>
                        </ul>
                    </section>
                </div>
                
                <aside class="sidebar">
                    <div class="ad-container ad-sidebar sticky">
                        <ins class="adsbygoogle"
                             style="display:block"
                             data-ad-client="ca-pub-5635114711353420"
                             data-ad-slot="4175507517"
                             data-ad-format="auto"
                             data-full-width-responsive="true"></ins>
                    </div>
                    
                    <section class="related-topics">
                        <h3>Related Advanced Topics</h3>
                        <ul class="topic-list">
                            <li><a href="noncommutative-geometry.html">Non-commutative Geometry</a></li>
                            <li><a href="higher-category-theory.html">Higher Category Theory</a></li>
                            <li><a href="symplectic-geometry.html">Symplectic Geometry</a></li>
                        </ul>
                    </section>
                </aside>
            </div>
        </div>
    </main>

    <script>
        // Cobordism 3D Visualization
        function createCobordismVisualization() {
            const container = document.getElementById('cobordism-3d');
            const width = container.clientWidth || 800;
            const height = 500;
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Create a pair of pants cobordism
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // Create vertices for cobordism
            const segments = 50;
            const radiusTop = 2;
            const radiusBottom1 = 1.5;
            const radiusBottom2 = 1.5;
            const height = 5;
            
            // Top circle
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                vertices.push(
                    Math.cos(theta) * radiusTop,
                    height,
                    Math.sin(theta) * radiusTop
                );
            }
            
            // Bottom circles
            for (let i = 0; i <= segments / 2; i++) {
                const theta = (i / (segments / 2)) * Math.PI;
                vertices.push(
                    Math.cos(theta) * radiusBottom1 - 2,
                    0,
                    Math.sin(theta) * radiusBottom1
                );
            }
            
            for (let i = 0; i <= segments / 2; i++) {
                const theta = (i / (segments / 2)) * Math.PI;
                vertices.push(
                    Math.cos(theta + Math.PI) * radiusBottom2 + 2,
                    0,
                    Math.sin(theta + Math.PI) * radiusBottom2
                );
            }
            
            // Create interpolated surface
            for (let h = 1; h < 5; h++) {
                const t = h / 5;
                const y = height * (1 - t);
                
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    let x, z;
                    
                    if (theta < Math.PI) {
                        // Interpolate to left circle
                        const s = theta / Math.PI;
                        x = Math.cos(theta) * (radiusTop * (1-t) + radiusBottom1 * t) - 2 * t;
                        z = Math.sin(theta) * (radiusTop * (1-t) + radiusBottom1 * t);
                    } else {
                        // Interpolate to right circle
                        const s = (theta - Math.PI) / Math.PI;
                        x = Math.cos(theta) * (radiusTop * (1-t) + radiusBottom2 * t) + 2 * t;
                        z = Math.sin(theta) * (radiusTop * (1-t) + radiusBottom2 * t);
                    }
                    
                    vertices.push(x, y, z);
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            // Create mesh
            const material = new THREE.MeshPhongMaterial({
                color: 0x3498db,
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            
            const cobordism = new THREE.Mesh(geometry, material);
            scene.add(cobordism);
            
            // Add boundary circles
            const boundaryMaterial = new THREE.LineBasicMaterial({ color: 0xe74c3c, linewidth: 3 });
            
            // Top boundary
            const topBoundary = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                topBoundary.push(new THREE.Vector3(
                    Math.cos(theta) * radiusTop,
                    height,
                    Math.sin(theta) * radiusTop
                ));
            }
            const topLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(topBoundary),
                boundaryMaterial
            );
            scene.add(topLine);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 2.5, 0);
            
            // Store for animation
            window.cobordismScene = { scene, camera, renderer, cobordism };
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                cobordism.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        function animateCobordism() {
            if (window.cobordismScene) {
                let t = 0;
                const interval = setInterval(() => {
                    t += 0.02;
                    if (t > 1) {
                        clearInterval(interval);
                        return;
                    }
                    
                    // Animate morphing
                    window.cobordismScene.cobordism.scale.y = 1 + 0.3 * Math.sin(t * Math.PI);
                }, 30);
            }
        }
        
        // Quantum Group Visualization
        function createQuantumGroupVisualization() {
            // Weight diagram for U_q(sl_2) representations
            const data = [];
            const q = Math.exp(Math.PI * Math.sqrt(-1) / 6); // Root of unity
            
            // Generate weight spaces
            for (let j = 0; j <= 4; j += 0.5) {
                const weights = [];
                const dims = [];
                
                for (let m = -j; m <= j; m++) {
                    weights.push(m);
                    // Quantum dimension
                    const qDim = Math.sin((2*j + 1) * Math.PI / 12) / Math.sin(Math.PI / 12);
                    dims.push(qDim);
                }
                
                const trace = {
                    x: weights,
                    y: Array(weights.length).fill(j),
                    mode: 'markers',
                    type: 'scatter',
                    marker: {
                        size: dims.map(d => d * 10),
                        color: `hsl(${j * 60}, 70%, 50%)`
                    },
                    name: `j = ${j}`
                };
                data.push(trace);
            }
            
            const layout = {
                title: 'U_q(sl₂) Weight Diagrams',
                xaxis: { title: 'Weight', dtick: 1 },
                yaxis: { title: 'Spin j' },
                showlegend: true
            };
            
            Plotly.newPlot('quantum-group-viz', data, layout, {responsive: true});
        }
        
        // Knot Visualizations
        function createTrefoilKnot() {
            const container = document.getElementById('trefoil-knot');
            const svg = d3.select(container)
                .append('svg')
                .attr('width', 300)
                .attr('height', 300);
            
            const g = svg.append('g')
                .attr('transform', 'translate(150, 150)');
            
            // Parametric trefoil
            const path = d3.path();
            const scale = 80;
            
            for (let t = 0; t <= 2 * Math.PI; t += 0.01) {
                const x = scale * (Math.sin(t) + 2 * Math.sin(2 * t)) / 3;
                const y = scale * (Math.cos(t) - 2 * Math.cos(2 * t)) / 3;
                
                if (t === 0) {
                    path.moveTo(x, y);
                } else {
                    path.lineTo(x, y);
                }
            }
            path.closePath();
            
            g.append('path')
                .attr('d', path.toString())
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 8)
                .attr('stroke-linejoin', 'round')
                .attr('stroke-linecap', 'round');
            
            // Add over/under crossings
            const crossings = [
                { x: 0, y: -40, over: true },
                { x: 35, y: 20, over: false },
                { x: -35, y: 20, over: true }
            ];
            
            crossings.forEach(crossing => {
                if (!crossing.over) {
                    g.append('rect')
                        .attr('x', crossing.x - 15)
                        .attr('y', crossing.y - 15)
                        .attr('width', 30)
                        .attr('height', 30)
                        .attr('fill', '#f8f9fa');
                }
            });
        }
        
        function createHopfLink() {
            const container = document.getElementById('hopf-link');
            const svg = d3.select(container)
                .append('svg')
                .attr('width', 300)
                .attr('height', 300);
            
            const g = svg.append('g')
                .attr('transform', 'translate(150, 150)');
            
            // First circle
            g.append('circle')
                .attr('cx', -30)
                .attr('cy', 0)
                .attr('r', 60)
                .attr('fill', 'none')
                .attr('stroke', '#e74c3c')
                .attr('stroke-width', 8);
            
            // Mask for under-crossing
            const mask = g.append('mask')
                .attr('id', 'hopf-mask');
            
            mask.append('rect')
                .attr('x', -150)
                .attr('y', -150)
                .attr('width', 300)
                .attr('height', 300)
                .attr('fill', 'white');
            
            mask.append('rect')
                .attr('x', 20)
                .attr('y', -15)
                .attr('width', 30)
                .attr('height', 30)
                .attr('fill', 'black');
            
            // Second circle
            g.append('circle')
                .attr('cx', 30)
                .attr('cy', 0)
                .attr('r', 60)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 8)
                .attr('mask', 'url(#hopf-mask)');
        }
        
        // Braid Group Visualization
        function createBraidVisualization() {
            const container = document.getElementById('braid-viz');
            const svg = d3.select(container)
                .append('svg')
                .attr('width', '100%')
                .attr('height', 300);
            
            const width = container.clientWidth;
            const height = 300;
            
            generateBraid();
        }
        
        function generateBraid() {
            const container = document.getElementById('braid-viz');
            const svg = d3.select(container).select('svg');
            svg.selectAll('*').remove();
            
            const width = container.clientWidth;
            const height = 300;
            const numStrands = parseInt(document.getElementById('braid-strands').value);
            document.getElementById('strand-count').textContent = numStrands;
            
            const strandSpacing = width / (numStrands + 1);
            const numCrossings = Math.floor(Math.random() * 8) + 4;
            
            // Draw strands
            const strands = [];
            for (let i = 0; i < numStrands; i++) {
                const points = [];
                let x = strandSpacing * (i + 1);
                
                for (let j = 0; j <= numCrossings + 1; j++) {
                    const y = (j / (numCrossings + 1)) * height;
                    points.push({ x: x, y: y });
                }
                strands.push(points);
            }
            
            // Apply random crossings
            for (let j = 1; j <= numCrossings; j++) {
                if (Math.random() < 0.7) {
                    const strand1 = Math.floor(Math.random() * (numStrands - 1));
                    const strand2 = strand1 + 1;
                    
                    // Swap x-coordinates
                    const temp = strands[strand1][j].x;
                    strands[strand1][j].x = strands[strand2][j].x;
                    strands[strand2][j].x = temp;
                }
            }
            
            // Draw strands with over/under crossings
            strands.forEach((strand, i) => {
                const line = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveMonotoneY);
                
                svg.append('path')
                    .datum(strand)
                    .attr('d', line)
                    .attr('fill', 'none')
                    .attr('stroke', d3.schemeCategory10[i % 10])
                    .attr('stroke-width', 6)
                    .attr('stroke-linecap', 'round');
            });
        }
        
        // Fusion Rules Table
        function createFusionTable() {
            const container = document.getElementById('fusion-table');
            const k = 3; // SU(2) level 3
            
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            
            // Header
            const header = table.createTHead();
            const headerRow = header.insertRow();
            headerRow.insertCell().textContent = '⊗';
            
            for (let j = 0; j <= k/2; j += 0.5) {
                const th = document.createElement('th');
                th.textContent = j;
                th.style.padding = '10px';
                th.style.borderBottom = '2px solid #ddd';
                headerRow.appendChild(th);
            }
            
            // Body
            const tbody = table.createTBody();
            for (let j1 = 0; j1 <= k/2; j1 += 0.5) {
                const row = tbody.insertRow();
                const labelCell = row.insertCell();
                labelCell.textContent = j1;
                labelCell.style.fontWeight = 'bold';
                labelCell.style.borderRight = '2px solid #ddd';
                labelCell.style.padding = '10px';
                
                for (let j2 = 0; j2 <= k/2; j2 += 0.5) {
                    const cell = row.insertCell();
                    cell.style.padding = '10px';
                    cell.style.border = '1px solid #eee';
                    
                    // Fusion rules
                    const fusionResult = [];
                    for (let j3 = Math.abs(j1 - j2); j3 <= Math.min(j1 + j2, k - j1 - j2); j3++) {
                        if (j3 <= k/2) fusionResult.push(j3);
                    }
                    
                    cell.textContent = fusionResult.join(' ⊕ ') || '0';
                }
            }
            
            container.appendChild(table);
        }
        
        // Modular S-Matrix
        function createModularSMatrix() {
            const k = 5; // Level
            const labels = [];
            const sMatrix = [];
            
            // Generate S-matrix for SU(2)_k
            for (let i = 0; i <= k; i++) {
                labels.push(`V_${i}`);
                const row = [];
                for (let j = 0; j <= k; j++) {
                    const s_ij = Math.sqrt(2/(k+2)) * Math.sin((i+1)*(j+1)*Math.PI/(k+2));
                    row.push(s_ij);
                }
                sMatrix.push(row);
            }
            
            const data = [{
                z: sMatrix,
                x: labels,
                y: labels,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0
            }];
            
            const layout = {
                title: 'Modular S-Matrix for SU(2)₅',
                xaxis: { title: 'Representation' },
                yaxis: { title: 'Representation' }
            };
            
            Plotly.newPlot('modular-s-matrix', data, layout, {responsive: true});
        }
        
        // Extended TQFT Visualization
        function createExtendedTQFTVisualization() {
            const container = document.getElementById('extended-tqft-viz');
            const svg = d3.select(container)
                .append('svg')
                .attr('width', '100%')
                .attr('height', 400);
            
            const width = container.clientWidth || 800;
            const height = 400;
            
            const levels = [
                { name: '0-manifolds', y: 50, examples: ['points'] },
                { name: '1-manifolds', y: 150, examples: ['circles', 'intervals'] },
                { name: '2-manifolds', y: 250, examples: ['spheres', 'tori'] },
                { name: '3-manifolds', y: 350, examples: ['S³', 'lens spaces'] }
            ];
            
            const assignments = [
                { name: '3-categories', y: 50 },
                { name: '2-categories', y: 150 },
                { name: '1-categories', y: 250 },
                { name: 'vector spaces', y: 350 }
            ];
            
            // Draw levels
            levels.forEach((level, i) => {
                svg.append('rect')
                    .attr('x', 50)
                    .attr('y', level.y - 30)
                    .attr('width', 200)
                    .attr('height', 60)
                    .attr('fill', d3.schemeCategory10[i])
                    .attr('opacity', 0.3)
                    .attr('rx', 5);
                
                svg.append('text')
                    .attr('x', 150)
                    .attr('y', level.y)
                    .attr('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .text(level.name);
                
                svg.append('text')
                    .attr('x', 150)
                    .attr('y', level.y + 20)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(level.examples.join(', '));
            });
            
            // Draw assignments
            assignments.forEach((assignment, i) => {
                svg.append('rect')
                    .attr('x', width - 250)
                    .attr('y', assignment.y - 30)
                    .attr('width', 200)
                    .attr('height', 60)
                    .attr('fill', d3.schemeCategory10[i + 4])
                    .attr('opacity', 0.3)
                    .attr('rx', 5);
                
                svg.append('text')
                    .attr('x', width - 150)
                    .attr('y', assignment.y)
                    .attr('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .text(assignment.name);
            });
            
            // Draw arrows
            for (let i = 0; i < levels.length; i++) {
                svg.append('line')
                    .attr('x1', 250)
                    .attr('y1', levels[i].y)
                    .attr('x2', width - 250)
                    .attr('y2', assignments[i].y)
                    .attr('stroke', '#666')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)');
            }
            
            // Arrow marker
            svg.append('defs')
                .append('marker')
                .attr('id', 'arrowhead')
                .attr('markerWidth', 10)
                .attr('markerHeight', 10)
                .attr('refX', 10)
                .attr('refY', 5)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 10 5 L 0 10 Z')
                .attr('fill', '#666');
            
            // Label
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('Extended TQFT: Z');
        }
        
        // Initialize all visualizations
        document.addEventListener('DOMContentLoaded', () => {
            createCobordismVisualization();
            createQuantumGroupVisualization();
            createTrefoilKnot();
            createHopfLink();
            createBraidVisualization();
            createFusionTable();
            createModularSMatrix();
            createExtendedTQFTVisualization();
            
            // Event listeners
            document.getElementById('braid-strands').addEventListener('input', generateBraid);
        });
    </script>
    
    <!-- KaTeX -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });
        });
    </script>
    
    <!-- AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5635114711353420"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</body>
</html>